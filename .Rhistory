load("~/R/Condatis4NatRec/env.RData")
ext <- extent(Eng_bound) #extent of the England boundaries raster
#Select raster resolution
gridsize <- 50
r <- raster(ext, res=gridsize)
###Test region
test_area<-st_read("spatial_data/test_area.shp")
library (sf)
library(raster)
###Test region
test_area<-st_read("spatial_data/test_area.shp")
test_N_heath_shp<- st_intersection(N_heath_shp, test_area)
plot(test_N_heath_shp)
plot(test_N_heath_shp$mainhabs)
View(test_N_heath_shp)
test_N_heath_shp<- st_intersection(N_heath_shp$mainhabs, test_area)
test_N_heath_shp<- st_intersection(N_heath_shp, test_area)
test_N_heath_shp<- st_intersection(N_heath_shp, test_area)
test_N_heath_50m<-rasterize (test_N_heath_shp, r,1)
ext <- extent(Eng_bound) #extent of the England boundaries raster
#Select raster resolution
gridsize <- 50
r <- raster(ext, res=gridsize)
test_N_heath_50m<-rasterize (test_N_heath_shp, r,1)
plot(test_N_heath_50m)
plot(test_N_heath_50m+test_area)
test_N_heath_int<- aggregate(N_heath, fact = 20, fun= sum, na.rm=TRUE)
test_N_heath_int<- aggregate(test_N_heath_50m, fact = 20, fun= sum, na.rm=TRUE)
View(test_N_heath_int)
test_N_heath_1km<- setValues(test_N_heath_int,values = (test_N_heath_int@data@values)*2500)/100000)
test_N_heath_1km<- calc((test_N_heath_int*2500)/1000000)
test_N_heath_1km<- calc(test_N_heath_int,(test_N_heath_int*2500)/1000000, na.rm=TRUE)
test_N_heath_1km<- calc(test_N_heath_int, fun=(test_N_heath_int*2500)/1000000, na.rm=TRUE)
test_N_heath_1km<- calc(test_N_heath_int, fun=test_N_heath_int*2500/1000000, na.rm=TRUE)
values<-test_N_heath_int*2500/1000000
test_N_heath_1km<- setValues(test_N_heath_int, values, na.rm=TRUE)
values<-as.matrix.data.frame(test_N_heath_int*2500/1000000)
rm(values)
test_N_heath_1km<- calc(test_N_heath_int, fun = (values(test_N_heath_int)*2500)/1000000, na.rm=TRUE)
test_N_heath_1km<- raster::calc(test_N_heath_int, fun = (test_N_heath_int*2500)/1000000,na.rm=TRUE)
test_N_heath_1km<- raster::calc(test_N_heath_int, fun = (values*2500)/1000000,na.rm=TRUE)
View(test_N_heath_int)
plot(test_N_heath_int)
test_N_heath_1km<-(test_N_heath_int*2500)/1000000
plot(test_N_heath_1km)
st_scrs (test_N_heath_1km)
st_crs (test_N_heath_1km)
st_crs (test_N_heath_1km)<-"EPSG:27700"
crs(test_N_heath_1km)
crs(test_N_heath_1km)<-"EPSG:27700"
crs(test_N_heath_1km)
writeRaster(test_N_heath_1km,"spatial_data/test_N_heath_1km.tif")
crs(test_N_heath_50m)<-"EPSG:27700"
writeRaster(test_N_heath_50m,"spatial_data/test_N_heath_50m.tif")
load("~/R/Condatis4NatRec/env.RData")
load("~/R/Condatis4NatRec/.RData")
#Convert to raster with the characteristics of the England boundaries raster
Eng_bound<-raster("spatial_data/engboundary1kmBNG.tif")#extent reference w/British National Grid
library (sf)
library(raster)
#Read original Priority Habitat Inventory England (phi) North
N_phi<-st_read("spatial_data/derived/Priority_Habitat_Inventory_England_1.shp")
S_phi<-st_read("spatial_data/derived/Priority_Habitat_Inventory_England_2.shp")
#subset heathland habitats
N_heath<- N_phi[grep('*HEAT',N_phi$habcodes),]
S_heath<- S_phi[grep('*HEAT',S_phi$habcodes),]
st_write(N_heath, "spatial_data/derived", "N_heath", driver= "ESRI Shapefile")
st_write(S_heath, "spatial_data/derived", "S_heath", driver= "ESRI Shapefile")
#Join north and south
phi_full<- st_union(N_heath, S_heath)
#Join north and south
phi_full<- merge(N_heath, S_heath, all=TRUE)
#Join north and south
st_geometry(N_heath)
#Join north and south
phi_full<- rbind(N_heath, S_heath)
st_write(phi_full,"spatial_data/derived", "Nat_heath", driver= "ESRI Shapefile")
#Convert to raster with the characteristics of the England boundaries raster
Eng_bound<-raster("spatial_data/derived/england.anything.100.tif")#extent reference w/British National Grid
# Set up a raster "template" to rasterize PHI shapefile
ext <- extent(Eng_bound) #extent of the England boundaries raster
#Select raster resolution
gridsize <- 250
r <- raster(ext, res=gridsize)
###Test region
test_area<-st_read("spatial_data/derived/test_area.shp")
test_heath<- st_intersection(phi_full, test_area) #clip shapefile with test region
test_heath_250m<-rasterize (test_heath, r,getCover=TRUE,na.rm=TRUE) #convert to 250m-resolution raster with the extent of the boundaries. The value is the fraction of the 250m cell that is covered by the polygons.The fraction is estimated by dividing each cell into 100 subcells (25m) and determining presence/absence of the polygon in the center of each subcell
crs(test_heath_250m)<-"EPSG:27700" #assign spatial reference British National Grid
writeRaster(test_heath_250m,"spatial_data/test_heath_250m.tif") #save raster for local scale analyses
test_heath_1km<- aggregate(test_heath_250m, fact = 4, fun= sum, na.rm=TRUE)/16 #rescale raster to 1km-resolution where raster value equals to the sum of 250m-pixels divided by 16 (no of pixes within
crs(test_heath_1km)<-"EPSG:27700" #assign spatial reference British National Grid
writeRaster(test_heath_1km,"spatial_data/test_heath_1km.tif")
test_heath_250m<-rasterize (test_heath, r,getCover=TRUE) #convert to 250m-resolution raster with the extent of the boundaries. The value is the fraction of the 250m cell that is covered by the polygons.The fraction is estimated by dividing each cell into 100 subcells (25m) and determining presence/absence of the polygon in the center of each subcell
crs(test_heath_250m)<-"EPSG:27700" #assign spatial reference British National Grid
writeRaster(test_heath_250m,"spatial_data/test_heath_250m.tif") #save raster for local scale analyses
test_heath_1km<- aggregate(test_heath_250m, fact = 4, fun= sum, na.rm=TRUE)/16 #rescale raster to 1km-resolution where raster value equals to the sum of 250m-pixels divided by 16 (no of pixes within
crs(test_heath_1km)<-"EPSG:27700" #assign spatial reference British National Grid
writeRaster(test_heath_1km,"spatial_data/test_heath_1km.tif")
NAvalue(nat_heath_250m) <- 0 #All ceros convertted to NA
NAvalue(test_heath_250m) <- 0 #All ceros convertted to NA
crs(test_heath_250m)<-"EPSG:27700" #assign spatial reference British National Grid
writeRaster(test_heath_250m,"spatial_data/derived/test_heath_250m.tif") #save raster for local scale analyses
writeRaster(test_heath_250m,"spatial_data/derived/test_heath_250m.tif", overwrite=TRUE) #save raster for local scale analyses
test_heath_1km<- aggregate(test_heath_250m, fact = 4, fun= sum, na.rm=TRUE)/16 #rescale raster to 1km-resolution where raster value equals to the sum of 250m-pixels divided by 16 (no of pixes within
crs(test_heath_1km)<-"EPSG:27700" #assign spatial reference British National Grid
writeRaster(test_heath_1km,"spatial_data/derived/test_heath_1km.tif")
writeRaster(test_heath_1km,"spatial_data/derived/test_heath_1km.tif",overwrite=TRUE)
library(raster)
library(igraph)
library(rgdal)
library(rgeos)
region<-raster("spatial_data/derived/england.anything.100.tif")
plot(region)
extent(region)
#class       : Extent
#xmin        : 80000
#xmax        : 660000
#ymin        : 0
#ymax        : 660000
crs(region)
#resolution england.anything
resn<- res(region)[1]
#resolution for condatis
bigresn<- 1000
aggfactor<- round (bigresn/resn)
loreg1<- aggregate(region, fact=aggfactor, fun=max,na.rm=T)
freq(loreg1)
loregionb<- boundaries(loreg1>= 0, type="outer") #detects boundaries with NA region
loreg1<- subs(loreg1, data.frame(by=c(0,NaN),which=c(1,0)),subsWithNA=FALSE) #needed for subtraction
plot(loreg1)
plot(loregionb)#as well as islands, there are a couple gaps at the edges where boundary could not extend out
freq(loregionb)
bufferb<-buffer(loregionb, width=20000,  doEdge=TRUE)#20 km just enough to join scilly isles
plot(bufferb)#original land and buffer become =1
bufferb<-bufferb-loreg1
plot(bufferb)#original land and buffer become =1
bpt<-rasterToPoints(loregionb,fun=function(x){x>0},spatial=F)
#select the most southerly point on the boundary
distN<- rasterize(as.data.frame(bpt[order(bpt[,"y"]),1:2])[1,],loregionb,field=2,update=T)
plot(distN)#south-east tip chosen
points(as.data.frame(bpt[order(bpt[,"y"]),1:2])[1,],pch=15)
#include the buffer in the area to calculate grid distances
distN2<-cover(distN,bufferb)
freq(distN2)
distN<-gridDistance(x=distN2, origin=2, omit=c(0,NA,NaN))
distN<- distN/cellStats(distN, stat='max', na.rm=TRUE)
plot(distN)
##reduce data to just boundary again
distN2<- distN*loregionb
plot(distN)
plot(distN2)
##reduce data to just boundary again
distN2<- distN*loregionb
bpt<-rasterToPoints(distN2,spatial=F)
#select points closest to halfway round in either direction
ew<- bpt[order(abs(bpt[,"layer"]-0.5)),][1:16,]
#of those, select the most westerly for new start
distE<- rasterize(as.data.frame(ew[order(ew[,"x"]),1:2])[1,],loregionb,field=2,update=T)
plot(distE)
points(as.data.frame(ew[order(ew[,"x"]),1:2])[1,],pch=15)#chosen point near Morecambe
#include the buffer in the area to calculate grid distances
distE2<-cover(distE,bufferb)
distE<-gridDistance(x=distE2, origin=2, omit=c(0,NA,NaN))
distE<- distE/cellStats(distE, stat='max', na.rm=TRUE)
plot(distE)
##reduce data to just boundary again
distE2<- distE*loregionb
#######combine 2 axes in a data frame#########
bpt<-as.data.frame(bpt)
names(bpt)[3]<-"distN"
bpt<-merge(bpt,as.data.frame(rasterToPoints(distE2,spatial=F)))
names(bpt)[4]<-"distE"
bpt$sector<- paste( c("S","N")[1+(bpt$distN>0.5)],c("W","E")[1+(bpt$distE>0.5)])
points(bpt$x,bpt$y,pch=19,col=as.numeric(as.factor(bpt$sector)))
bpt$sector[(bpt$distN>0.875)]<-"N"
bpt$sector[(bpt$distN<0.125)]<-"S"
bpt$sector[(bpt$distE>0.875)]<-"E"
bpt$sector[(bpt$distE<0.125)]<-"W"
bpt$angle<-atan2(bpt$distN-0.5,bpt$distE-0.5)
mypal<-rainbow(20)[c(1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16)]
points(bpt$x,bpt$y,pch=19,col=mypal[as.numeric(cut(bpt$angle,breaks=16))])#looks reasonable
legend("topleft",legend=1:16,pch=15,col=mypal)
bpt$cutangle<-as.numeric(cut(bpt$angle,breaks=16))
bpt$sector2<-factor(bpt$cutangle,labels=c(
"W","S W","S W","S","S","S E","S E","E" ,"E"  ,"N E","N E", "N", "N","N W", "N W","W"))
table(bpt$sector2)
points(bpt$x,bpt$y,pch=19,col=mypal[as.numeric(bpt$sector2)])#discontinuities have gone
legend("topleft",legend=levels(bpt$sector2),pch=15,col=mypal[1:8])
bpt$angle<-atan2(bpt$distN-0.5,bpt$distE-0.5)
mypal<-rainbow(20)[c(1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16)]
points(bpt$x,bpt$y,pch=19,col=mypal[as.numeric(cut(bpt$angle,breaks=16))])#looks reasonable
legend("topleft",legend=1:16,pch=15,col=mypal)
bpt$cutangle<-as.numeric(cut(bpt$angle,breaks=16))
bpt$sector2<-factor(bpt$cutangle,labels=c(
"W","S W","S W","S","S","S E","S E","E" ,"E"  ,"N E","N E", "N", "N","N W", "N W","W"))
table(bpt$sector2)
points(bpt$x,bpt$y,pch=19,col=mypal[as.numeric(bpt$sector2)])#discontinuities have gone
legend("topleft",legend=levels(bpt$sector2),pch=15,col=mypal[1:8])
bpt<-as.data.frame(bpt)
names(bpt)[3]<-"distN"
bpt<-merge(bpt,as.data.frame(rasterToPoints(distE2,spatial=F)))
names(bpt)[4]<-"distE"
#categorise the boundary based on relative distances N and E
bpt$sector<- paste( c("S","N")[1+(bpt$distN>0.5)],c("W","E")[1+(bpt$distE>0.5)])
points(bpt$x,bpt$y,pch=19,col=as.numeric(as.factor(bpt$sector)))
bpt$sector[(bpt$distN>0.875)]<-"N"
bpt$sector[(bpt$distN<0.125)]<-"S"
bpt$sector[(bpt$distE>0.875)]<-"E"
bpt$sector[(bpt$distE<0.125)]<-"W"
plot(distN)
##reduce data to just boundary again
distN2<- distN*loregionb
bpt<-rasterToPoints(distN2,spatial=F)
#select points closest to halfway round in either direction
ew<- bpt[order(abs(bpt[,"layer"]-0.5)),][1:16,]
#of those, select the most westerly for new start
distE<- rasterize(as.data.frame(ew[order(ew[,"x"]),1:2])[1,],loregionb,field=2,update=T)
plot(distE)
points(as.data.frame(ew[order(ew[,"x"]),1:2])[1,],pch=15)#chosen point near Morecambe
#include the buffer in the area to calculate grid distances
distE2<-cover(distE,bufferb)
distE<-gridDistance(x=distE2, origin=2, omit=c(0,NA,NaN))
distE<- distE/cellStats(distE, stat='max', na.rm=TRUE)
plot(distE)
##reduce data to just boundary again
distE2<- distE*loregionb
#######combine 2 axes in a data frame#########
bpt<-as.data.frame(bpt)
names(bpt)[3]<-"distN"
bpt<-merge(bpt,as.data.frame(rasterToPoints(distE2,spatial=F)))
names(bpt)[4]<-"distE"
#categorise the boundary based on relative distances N and E
bpt$sector<- paste( c("S","N")[1+(bpt$distN>0.5)],c("W","E")[1+(bpt$distE>0.5)])
points(bpt$x,bpt$y,pch=19,col=as.numeric(as.factor(bpt$sector)))
bpt$sector[(bpt$distN>0.875)]<-"N"
bpt$sector[(bpt$distN<0.125)]<-"S"
bpt$sector[(bpt$distE>0.875)]<-"E"
bpt$sector[(bpt$distE<0.125)]<-"W"
bpt$angle<-atan2(bpt$distN-0.5,bpt$distE-0.5)
mypal<-rainbow(20)[c(1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16)]
points(bpt$x,bpt$y,pch=19,col=mypal[as.numeric(cut(bpt$angle,breaks=16))])#looks reasonable
legend("topleft",legend=1:16,pch=15,col=mypal)
bpt$cutangle<-as.numeric(cut(bpt$angle,breaks=16))
bpt$sector2<-factor(bpt$cutangle,labels=c(
"W","S W","S W","S","S","S E","S E","E" ,"E"  ,"N E","N E", "N", "N","N W", "N W","W"))
table(bpt$sector2)
points(bpt$x,bpt$y,pch=19,col=mypal[as.numeric(bpt$sector2)])#discontinuities have gone
legend("topleft",legend=levels(bpt$sector2),pch=15,col=mypal[1:8])
bpt$sector<- bpt$sector2
write.csv(bpt[,1:6],"england.4directions.csv")
sectors<- rasterize(bpt[,c(1,2)],loregionb,field=as.numeric(bpt[,5]))
#numbered 1-8, would not accept factor so labels lost
#sectors<- rasterFromXYZ(bpt[,c(1,2,5)],crs=crs(loregionb),res=res(loregionb))#also does not work
crs(sectors)
writeRaster(sectors,"engboundary8sects1km_2.tif")
crs(sectors)
writeRaster(sectors,"spatial_data/derived/engboundary8sects1km_2.tif")
library (sf)
#Read original Priority Habitat Inventory England (phi) North
HN_L_heath<-st_read("spatial_data/original/Habitat_Networks_Lowland_Heathland/Habitat_Networks_(England)_-_Lowland_Heathland.shp")
HN_U_heath<-st_read("spatial_data/original/Habitat_Networks_Upland_Heathland/Habitat_Networks_(England)_-_Upland_Heathland.shp")
HN_L_heath
HN_heah<- rbind(HN_L_heath, HN_U_heath)
HN_heath<- rbind(HN_L_heath, HN_U_heath)
rm(HN_heah)
HN_heath<- rbind(HN_L_heath, HN_U_heath)
st_write(HN_heath,"spatial_data/derived", "NH_heath", driver= "ESRI Shapefile")
