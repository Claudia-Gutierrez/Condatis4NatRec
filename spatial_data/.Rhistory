setwd("C:/Users/Jenny Hodgson/Documents/workspace/indicators")
load(".Rdata")
ls()
rm(list=ls())
library(foreign)
patch<-read.dbf("C:/Users/Jenny Hodgson/Documents/workspace/lcm2015vector/lcmEngseminat2.dbf")
save(patch,file="snpatches.Rdata")
11*11
blocks<-c(1,9,25,49,121,225)
bbreaks<- 2^(log2(blocks)[1:5]  + diff(log2(blocks))/2)
bbreaks<- c(0,bbreaks,max(a))
a<- as.numeric(as.character(patch$npix)) #area in pixels
bbreaks<- 2^(log2(blocks)[1:5]  + diff(log2(blocks))/2)
bbreaks<- c(0,bbreaks,max(a))
acut<-cut(a,breaks=bbreaks)
table(acut)
table(acut)
atab<- table(patch$modal_clas,acut)
atab<- as.matrix(atab)
atab<-cbind(atab,apply(atab,1,sum))
atab<- as.data.frame(atab)
atab$class<-as.numeric(row.names(atab))
atab<- merge(atab,hlookup,by.x="class",by.y="LCM_class",all.x=T,all.y=F)
hlookup<- read.csv("Habitat_lookupTable.csv")
atab<- merge(atab,hlookup,by.x="class",by.y="LCM_class",all.x=T,all.y=F)
atab
aatab<- aggregate(atab[,2:8],by=atab[,10:11],FUN=sum)
aatab
aatab[,3:8]<- aatab[,3:8]/aatab[,9]
aatab
barplot(t(as.matrix(aatab[c(4,6,7),3:8])))
table(acut)/length(acut)
sizes<-data.frame(npix=blocks,range=names(table(acut)),semi.natural=table(acut)/length(acut))
sizes
sizes<-data.frame(npix=blocks,range=names(table(acut)),semi.natural=as.vector(table(acut)/length(acut)))
sizes
sizes<-cbind(sizes,t(as.matrix(aatab[c(4,6,7),3:8]))
)
sizes
names(sizes)[4:6]<- aatab$agg_class[c(4,6,7)]
sizes
aatab$agg_class
names(sizes)[4:6]<- as.character(aatab$agg_class[c(4,6,7)])
sizes
?write.csv
write.csv(sizes,"sizes.csv",row.names=F)
didist<- rep(sqrt(sizes$npix),times=c(1,2,3,4,4,3,2,1))
sqrt(sizes$npix)
sizes[,habtext]
hablabel<-"heath"
#what the focal habitat is called in the lookup table
habtext<- "heathland"
sizes[,habtext]
didist<- rep(sqrt(sizes$npix),times= round(sizes[,habtext]*1000))
length(didist)
ardist<- didist^2*resn*resn/1000/1000
regionfname<- "harrogate"
load(paste(regionfname,hablabel,"Rdata",sep="."))
load(paste(regionfname,hablabel,"hanski","Rdata",sep="."))
ardist<- didist^2*resn*resn/1000/1000
ncell(fhabitatreg)
library(raster)
library(rgdal)
ncell(fhabitatreg)
propnonhab<- (1-fhabitatbasics$proparea)*(fhabitatbasics$regarea/
(ncell(fhabitatreg)*resn*resn/1000/1000))
propnonhab
ardist<- didist^2*resn*resn/1000/1000
mean(ardist)
resn*resn/1000/1000/mean(ardist)
maxsamp<- round(10* fhabitatbasics$proparea * 0.025 * resn*resn/1000/1000/mean(ardist)* ncell(fhabitatreg)/propnonhab )
maxsamp
system.time({
chosen<- sampleRandom(fhabitatreg, size=maxsamp, na.rm=F,
cells=TRUE, rowcol=FALSE, xy=T, sp=FALSE, asRaster=FALSE,)
})
summary(chosen)
nhchosen<-chosen[!is.na(chosen$layer) & chosen$layer==0,]
chosen<-as.data.frame(chosen)
nhchosen<-chosen[!is.na(chosen$layer) & chosen$layer==0,]
dim(nhchosen)[1]/dim(chosen)[1]
propnonhab
with(nhchosen,plot(x,y))
nh1<- nhchosen[with(nhchosen,x>420000 & x<420500 & y> 460000 & y<460500),]
nh1
nh1<- nhchosen[with(nhchosen,x>420000 & x<421000 & y> 460000 & y<461000),]
nh1
nh1<- nhchosen[with(nhchosen,x>420000 & x<422000 & y> 460000 & y<462000),]
nh1
nhchosen$di<- sample(didist, dim(nhchosen)[1], replace =T)
nhchosen$patchid <- 1:( dim(nhchosen)[1])
nh1<- nhchosen[with(nhchosen,x>420000 & x<422000 & y> 460000 & y<462000),]
with(nh1,plot(x,y,pch=as.character(1:9)))
with(nh1,points(x,y,pch=0,cex=di))
(sqrt(max(sizes$npix))-1)/2
maxring<- (sqrt(max(sizes$npix))-1)/2
nh1
for(i in c(1:maxring)){#this will be the no. of cells to count away in each direction
side<-centrecells[(centrecells$di -1)/2 >= i,]
if(dim(side)[1]>0){
sideall<- side
sideall$x<- sideall$x - (i*resn)
sideall$y<- sideall$y - (i*resn)
for(j in (-i+1):i){
#left side
side2<- side
side2$x<- side2$x - (i*resn)
side2$y<- side2$y + (j*resn)
sideall<- rbind(sideall,side2)
#right side
side2<- side
side2$y<- side2$y - (i*resn)
side2$x<- side2$x + (j*resn)
sideall<- rbind(sideall,side2)
#right side
side2<- side
side2$x<- side2$x + (i*resn)
side2$y<- side2$y + (j*resn)
sideall<- rbind(sideall,side2)
#top side
side2<- side
side2$y<- side2$y + (i*resn)
side2$x<- side2$x + (j*resn)
if (j<i){#this to prevent last, top-right cell being duplicated
sideall<- rbind(sideall,side2)
}#end if
}#end j loop: filling 4 sides of square
morecells<-rbind(morecells,sideall)
}}#end if and i loop
morecells<-nh1
centrecells<-nh1
maxring<- (sqrt(max(sizes$npix))-1)/2
for(i in c(1:maxring)){#this will be the no. of cells to count away in each direction
side<-centrecells[(centrecells$di -1)/2 >= i,]
if(dim(side)[1]>0){
sideall<- side
sideall$x<- sideall$x - (i*resn)
sideall$y<- sideall$y - (i*resn)
for(j in (-i+1):i){
#left side
side2<- side
side2$x<- side2$x - (i*resn)
side2$y<- side2$y + (j*resn)
sideall<- rbind(sideall,side2)
#right side
side2<- side
side2$y<- side2$y - (i*resn)
side2$x<- side2$x + (j*resn)
sideall<- rbind(sideall,side2)
#right side
side2<- side
side2$x<- side2$x + (i*resn)
side2$y<- side2$y + (j*resn)
sideall<- rbind(sideall,side2)
#top side
side2<- side
side2$y<- side2$y + (i*resn)
side2$x<- side2$x + (j*resn)
if (j<i){#this to prevent last, top-right cell being duplicated
sideall<- rbind(sideall,side2)
}#end if
}#end j loop: filling 4 sides of square
morecells<-rbind(morecells,sideall)
}}#end if and i loop
with(morecells,plot(x,y,pch=4))
with(nh1,points(x,y,pch=0,cex=di))
with(nh1,text(x,y,di,col=2))
summary(morecells)
morecells<-nhchosen
centrecells<-nhchosen
maxring<- (sqrt(max(sizes$npix))-1)/2
for(i in c(1:maxring)){#this will be the no. of cells to count away in each direction
side<-centrecells[(centrecells$di -1)/2 >= i,]
if(dim(side)[1]>0){
sideall<- side
sideall$x<- sideall$x - (i*resn)
sideall$y<- sideall$y - (i*resn)
for(j in (-i+1):i){
#left side
side2<- side
side2$x<- side2$x - (i*resn)
side2$y<- side2$y + (j*resn)
sideall<- rbind(sideall,side2)
#right side
side2<- side
side2$y<- side2$y - (i*resn)
side2$x<- side2$x + (j*resn)
sideall<- rbind(sideall,side2)
#right side
side2<- side
side2$x<- side2$x + (i*resn)
side2$y<- side2$y + (j*resn)
sideall<- rbind(sideall,side2)
#top side
side2<- side
side2$y<- side2$y + (i*resn)
side2$x<- side2$x + (j*resn)
if (j<i){#this to prevent last, top-right cell being duplicated
sideall<- rbind(sideall,side2)
}#end if
}#end j loop: filling 4 sides of square
morecells<-rbind(morecells,sideall)
}}#end if and i loop
with(morecells,plot(x,y,pch=4))
with(nh1,points(x,y,pch=0,cex=di))
with(nh1,text(x,y,di,col=2))
with(morecells,plot(x,y,pch=46,col="gray"))
with(nhchosen,points(x,y,pch=0,cex=di))
with(morecells,plot(x,y,pch=46,col="gray"))
with(nhchosen,text(x,y,di,col=2))
?text
with(morecells,plot(x,y,pch=46,col="gray"))
with(nhchosen,text(x,y,di,col=2,pos=3,cex=0.3))
summary(morecells)
?rasterize
morecells2<-aggregate(morecells[,c("cell","layer")],by=morecells[,c("x","y")],FUN=min)
dim(morecells)
dim(morecells2)
nhchosen$patchid<- nhchosen$patchid+1
morecells2<-merge(morecells2,morecells,all.x=T,all.y=F)
summary(morecells2)
dim(morecells2)
morecells2$patchid<- morecells2$patchid+1
morecells$patchid<- morecells$patchid+1
plot(fhabitatreg)
ls()
morecells<-rasterize(x=morecells2[,c("x","y")],y=fhabitatreg, field=as.matrix(morecells2$patchid))
plot(morecells)
par(mfrow=c(1,2))
plot(morecells)
plot(fhabitatreg)
?raster
nonhab <- subs(x=fhabitatreg,y=data.frame(id=1, v=NA), subsWithNA=F)
morecells<-rasterize(x=morecells2[,c("x","y")],y=nonhab, field=as.matrix(morecells2$patchid),update=TRUE,updateValue='!NA'))
morecells<-rasterize(x=morecells2[,c("x","y")],y=nonhab, field=as.matrix(morecells2$patchid),update=TRUE,updateValue='!NA')
plot(morecells)
morecells2<-rasterToPoints(morecells,fun=function(x){x>0})
dim(morecells2)
summary(morecells2)
summary(nhchosen)
nhchosen<-nhchosen[nhchosen$patchid %in% morecells2$layer,] #so,only centres of those patches that have some area left
nhchosen<-nhchosen[nhchosen$patchid %in% morecells2[,"layer"],] #so,only centres of those patches that have some area left
dim(nhchosen)
morecells2<-as.data.frame(morecells2)
names(morecells2)[3]<-"patchid"
summary(morecells2)
ls()
names(hk2500)
plot(hk2500$conr)
plot(hk500$conr)
plot(hk2500$conr)
extent(hk2500$conr)
extent(hk500$conr)
extent(hk2500$conr-hk500$conr)
plot(hk2500$conr-hk500$conr)
plot(hk2500$conr-hk500$conr,col=cm.colors(20))
ls()
str(patch)
rm(patch)
q()
setwd("C:/Users/jhodgson/OneDrive - The University of Liverpool/Condatis4Naturerecovery/Spatial data/EnglandBoundary")#for desktop
region<-raster("england.anything.100.tif")
plot(region)
library(raster)
library(igraph)
library(rgdal)
library(rgeos)
region<-raster("england.anything.100.tif")
region<-raster("england.anything.100.tif")
plot(region)
extent(region)
res(region)
#resolution england.anything
resn<- res(region)[1]
#resolution for condatis
bigresn<- 1000
aggfactor<- round (bigresn/resn)
loreg1<- aggregate(region, fact=aggfactor, fun=max,na.rm=T)
freq(loreg1)
plot(loreg1)
loregionb<- boundaries(loreg1>= 0, type="outer")
plot(loregionb)#as well as islands, there are a couple gaps at the edges where boundary could not extend out
freq(loregionb)
#by making the boundary coarser, gaps disappear - we can use the coarser one to define sections
blower<- aggregate(loregionb, fact=10, fun=max,na.rm=T)
plot(blower)
extent(blower)
#by making the boundary coarser, gaps disappear - we can use the coarser one to define sections
blower<- aggregate(loregionb, fact=20, fun=max,na.rm=T)
plot(blower)
#by making the boundary coarser, gaps disappear - we can use the coarser one to define sections
blower<- aggregate(loregionb, fact=25, fun=max,na.rm=T)
plot(blower)
extent(blower)
#by making the boundary coarser, gaps disappear - we can use the coarser one to define sections
blower<- aggregate(loregionb, fact=40, fun=max,na.rm=T)
plot(blower)
?gridDistance
extent(blower)
bpt<-rasterToPoints(blower,fun=function(x){x>0},spatial=F)
#select the most southerly point on the boundary
distN<- rasterize(as.data.frame(bpt[order(bpt[,"y"]),1:2])[1,],blower,field=2,update=T)
plot(distN)#south-east tip chosen
#calculate stepwise distance around boundary from the south to all other points
distN2<-gridDistance(x=distN, origin=2, omit=c(0,NA,NaN))
distN<- distN2/cellStats(distN2, stat='max', na.rm=TRUE)
plot(distN)
bpt<-rasterToPoints(distN,spatial=F)
#select points closest to halfway round in either direction
ew<- bpt[order(abs(bpt[,"layer"]-0.5)),][1:16,]
#of those, select the most westerly for new start
distE<- rasterize(as.data.frame(ew[order(ew[,"x"]),1:2])[1,],blower,field=2,update=T)
plot(distE)#chosen point near Liverpool!
#calculate stepwise distance around boundary from the west to all other points
distE2<-gridDistance(x=distE, origin=2, omit=c(0,NA,NaN))
distE<- distE2/cellStats(distE2, stat='max', na.rm=TRUE)
plot(distE)
bpt<-rasterToPoints(loregionb,fun=function(x){x>0},spatial=F)
bpt<-as.data.frame(bpt)
bpt$distN <- extract(distN,bpt[,1:2])
bpt$distE <- extract(distE,bpt[,1:2])
#categorise the boundary based on relative distances N and E
bpt$sector<- paste( c("S","N")[1+(bpt$distN>0.5)],c("W","E")[1+(bpt$distE>0.5)])
points(bpt$x,bpt$y,pch=19,col=as.numeric(bpt$sector))#looks reasonable
summary(bpt)
points(bpt$x,bpt$y,pch=19,col=as.numeric(factor(bpt$sector)))#looks reasonable
bpt$sector[(bpt$distN>0.875)]<-"N"
bpt$sector[(bpt$distN<0.125)]<-"S"
bpt$sector[(bpt$distE>0.875)]<-"E"
bpt$sector[(bpt$distE<0.125)]<-"W"
bpt$sector<-factor(bpt$sector)
points(bpt$x,bpt$y,pch=19,col=as.numeric(bpt$sector))#looks reasonable
?boundaries
??buffer
bufferb<-buffer(loregionb, width=25000,  doEdge=TRUE)
plot(bufferb)
plot(loregionb)#as well as islands, there are a couple gaps at the edges where boundary could not extend out
plot(loreg1)
bufferb<-bufferb-loreg1
plot(bufferb)#original land and buffer become =1
loreg1<- subs(loreg1, data.frame(by=NaN,which=0))
freq(loreg1)
loreg1<- aggregate(region, fact=aggfactor, fun=max,na.rm=T)
loreg1<- subs(loreg1, data.frame(by=NaN,which=0),subsWithNA=FALSE)
freq(loreg1)
loreg1<- aggregate(region, fact=aggfactor, fun=max,na.rm=T)
plot(loreg1==0)
loregionb<- boundaries(loreg1>= 0, type="outer")
loreg1<- subs(loreg1, data.frame(by=NaN,which=0),subsWithNA=FALSE)
plot(loregionb)#as well as islands, there are a couple gaps at the edges where boundary could not extend out
freq(loregionb)
bufferb<-buffer(loregionb, width=25000,  doEdge=TRUE)
bufferb<-bufferb-loreg1
plot(bufferb)#original land and buffer become =1
getwd()
region<-raster("england.anything.100.tif")
#resolution england.anything
resn<- res(region)[1]
library(raster)
library(igraph)
library(rgdal)
library(rgeos)
region<-raster("england.anything.100.tif")
#resolution england.anything
resn<- res(region)[1]
#resolution for condatis
bigresn<- 1000
aggfactor<- round (bigresn/resn)
loreg1<- aggregate(region, fact=aggfactor, fun=max,na.rm=T)
loreg1<- subs(loreg1, data.frame(by=c(0,NaN),which=c(1,0)),subsWithNA=FALSE)
plot(loreg1)
loregionb<- boundaries(loreg1>= 1, type="outer")
freq(loregionb)
plot(loregionb)#as well as islands, there are a couple gaps at the edges where boundary could not extend out
plot(loreg1)
?boundaries
loreg1<- aggregate(region, fact=aggfactor, fun=max,na.rm=T)
loregionb<- boundaries(loreg1>= 0, type="outer") #detects boundaries with NA region
loreg1<- subs(loreg1, data.frame(by=c(0,NaN),which=c(1,0)),subsWithNA=FALSE) #needed for subtraction
plot(loregionb)#as well as islands, there are a couple gaps at the edges where boundary could not extend out
freq(loregionb)
bufferb<-buffer(loregionb, width=25000,  doEdge=TRUE)
plot(bufferb)#original land and buffer become =1
bufferb<-buffer(loregionb, width=20000,  doEdge=TRUE)
plot(bufferb)#original land and buffer become =1
bufferb<-bufferb-loreg1
plot(bufferb)#original land and buffer become =1
bpt<-rasterToPoints(loregionb,fun=function(x){x>0},spatial=F)
#select the most southerly point on the boundary
distN<- rasterize(as.data.frame(bpt[order(bpt[,"y"]),1:2])[1,],blower,field=2,update=T)
#select the most southerly point on the boundary
distN<- rasterize(as.data.frame(bpt[order(bpt[,"y"]),1:2])[1,],loregionb,field=2,update=T)
plot(distN)#south-east tip chosen
as.data.frame(bpt[order(bpt[,"y"]),1:2])[1,]
points(as.data.frame(bpt[order(bpt[,"y"]),1:2])[1,],pch=15)
#include the buffer in the area to calculate grid distances
distN2<-overlay(distN,bufferb,fun=max,na.rm=T)
freq(distN2)
distN<-gridDistance(x=distN2, origin=2, omit=c(0,NA,NaN))
distN<- distN/cellStats(distN, stat='max', na.rm=TRUE)
plot(distN)
plot(distN2)
#select the most southerly point on the boundary
distN<- rasterize(as.data.frame(bpt[order(bpt[,"y"]),1:2])[1,],loregionb,field=2,update=T)
freq(distN)
#include the buffer in the area to calculate grid distances
distN2<-cover(distN,bufferb)
freq(distN2)
plot(distN2)
distN<-gridDistance(x=distN2, origin=2, omit=c(0,NA,NaN))
distN<- distN/cellStats(distN, stat='max', na.rm=TRUE)
plot(distN)
distN2<- distN*loregionb
plot(distN2)
bpt<-rasterToPoints(distN2,spatial=F)
#select points closest to halfway round in either direction
ew<- bpt[order(abs(bpt[,"layer"]-0.5)),][1:16,]
#of those, select the most westerly for new start
distE<- rasterize(as.data.frame(ew[order(ew[,"x"]),1:2])[1,],loregionb,field=2,update=T)
plot(distE)#chosen point near Liverpool!
points(as.data.frame(ew[order(ew[,"x"]),1:2])[1,],pch=15)
#include the buffer in the area to calculate grid distances
distE2<-cover(distE,bufferb)
plot(distE)
plot(distE2)
distE<-gridDistance(x=distE2, origin=2, omit=c(0,NA,NaN))
distE<- distE/cellStats(distE, stat='max', na.rm=TRUE)
plot(distE)
##reduce data to just boundary again
distE2<- distE*loregionb
bpt<-as.data.frame(bpt)
names(bpt)[3]<-"distN"
summary(bpt)
dim(bpt)
bpt<-merge(bpt,as.data.frame(rasterToPoints(distE2,spatial=F)))
dim(bpt)
names(bpt)[4]<-"distE"
#categorise the boundary based on relative distances N and E
bpt$sector<- paste( c("S","N")[1+(bpt$distN>0.5)],c("W","E")[1+(bpt$distE>0.5)])
points(bpt$x,bpt$y,pch=19,col=as.numeric(as.factor(bpt$sector)))#looks reasonable
bpt$sector[(bpt$distN>0.875)]<-"N"
bpt$sector[(bpt$distN<0.125)]<-"S"
bpt$sector[(bpt$distE>0.875)]<-"E"
bpt$sector[(bpt$distE<0.125)]<-"W"
bpt$sector<-factor(bpt$sector)
points(bpt$x,bpt$y,pch=19,col=as.numeric(bpt$sector))#looks reasonable
?atan
bpt$angle<-atan2(bpt$distN-0.5,bpt$distE-0.5)
summary(bpt)
?cut
points(bpt$x,bpt$y,pch=19,col=as.numeric(as.factor(cut(bpt$angle,breaks=16))))#looks reasonable
legend("topleft",1:16,pch=15,col=16)
legend("topleft",legend=1:16,pch=15,col=1:16)
points(bpt$x,bpt$y,pch=19,col=rainbow(20)[as.numeric(cut(bpt$angle,breaks=16))])#looks reasonable
mypal<-rainbow(20)[1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16]
mypal<-rainbow(20)[c(1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16)]
points(bpt$x,bpt$y,pch=19,col=mypal[as.numeric(cut(bpt$angle,breaks=16))])#looks reasonable
legend("topleft",legend=1:16,pch=15,col=mypal)
?factor
bpt$cutangle<-as.numeric(cut(bpt$angle,breaks=16))
bpt$sector2<-factor(bpt$cutangle,labels=c(
"W","S W","S W","S","S","S E","S E","E" ,"E"  ,"N E","N E", "N", "N","N W", "N W","W"))
table(bpt$sector2)
points(bpt$x,bpt$y,pch=19,col=mypal[as.numeric(bpt$sector2)])#looks reasonable
legend("topleft",legend=levels(bpt$sector2),pch=15,col=mypal[1:8])
bpt$sector<- bpt$sector2
summary(bpt)
write.csv(bpt[,1:6],"england.4directions.csv")
?rasterize
sectors<- rasterize(bpt[,c(1,2,5)],loregionb,field=3)
sectors<- rasterize(bpt[,c(1,2)],loregionb,field=bpt$sector)
sectors<- rasterize(bpt[,c(1,2)],loregionb,field=bpt[,3])
plot(sectors)
sectors<- rasterize(bpt[,c(1,2)],loregionb,field=bpt[,5])
sectors<- rasterize(bpt[,c(1,2)],loregionb,field=as.factor(bpt[,5]))
?rasterFromXYZ
crs(loregionb)
sectors<- rasterFromXYZ(bpt[,c(1,2,5)],crs=crs(loregionb),res=res(loregionb))
plot(sectors)
sectors
loregionb
sectors<- rasterize(bpt[,c(1,2)],loregionb,field=as.numeric(bpt[,5]))
plot(sectors)
writeRaster(sectors,"engboundary8sects1km.tif")
sectors
?spTransform
?rgeos
??rgeos
